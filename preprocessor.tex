\section{Препроцессирование}

Препроцессирование получает на вход .cpp файл и выдает на выход .i файл. Препроцессирование выполняется программой называемой препроцессор.

Препроцессор проходит по входному файлу, копируя текст в выходной файл. Если он встречает строку начинающуются с символа {\bf \#}, он выполняет команду, которая записана после {\bf \#}. Такие команды называются директивами препроцессора.

Примером директивы препроцессора является директива {\bf \#include}.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#include "somefile.h"
\end{minted}

Когда препроцесор встречает эту директиву, он подставляет на её место текст файла {\bf somefile.h}. При этом текст файла {\bf somefile.h} тоже препроцессируется. Если в нём есть какие-то директивы то они будут выполнены.

Пусть даны следующие файлы
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
// print.h
void print(char const*);

// main.cpp
#include "print.h"

int main()
{
    print("Hello, world");
}
\end{minted}
Результатом препроцессирования {\bf main.cpp} будет:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void print(char const*);

int main()
{
    print("Hello, world");
}
\end{minted}
В этом можно убедиться выполним команду {\bf g++ -E main.cpp}. Ключ {\bf -E} говорит драйверу, что нужно лишь отпрепроцессировать входной файл.

Директива {\bf \#include} имеет две формы
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#include <somefile.h>
#include "somefile.h"
\end{minted}

Первая форма ищет файл {\bf somefile.h} в списке каталогов, называемых include directories. Их можно указать компилятору опцией {\bf -I}. Например:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{sh}
g++ -Isome/directory -Ianother/directory -I../and/another/one myfile.cpp
\end{minted}
Файлы ищутся в этих директориях слева направо. Препроцессор автоматически добавляет в конец этого списка пути к директориям в которых лежат хедера стандартной библиотеки.

Вторая форма директивы {\bf \#include} ищет {\bf somefile.h} сначала в текущем каталоге, а потом в include directories.

В стандарте определены следующие директивы препроцессора:
\begin{enumerate}
\item \#define
\item \#elif
\item \#else
\item \#error
\item \#endif
\item \#if
\item \#ifdef
\item \#ifndef
\item \#include
\item \#pragma
\item \#undef
\end{enumerate}

Рассмотрим директиву {\bf \#define} на примере:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define PI 3.14159265

double circumference(double r)
{
    return 2 * PI * r;
}
\end{minted}
Здесь директива {\bf \#define} определяет макрос с именем {\bf PI}. Текст, который идет после имени макроса, называется replacement'ом. Replacement отделяется от имени макроса пробелом и распростроняется до конца строки. Все вхождения идентификатора {\bf PI} ниже этой директивы будут заменены на replacement. Результатом препроцессирования примера выше является следующий текст:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
double circumference(double r)
{
    return 2 * 3.14159265 * r;
}
\end{minted}

Приведенная выше форма директивы {\bf \#define} называется object-like. Существует вторая форма этой директивы, называемая function-like:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define MIN(x, y) x < y ? x : y

printf("%d", MIN(4, 5));
\end{minted}
Результатом препроцессирования этого фрагмента кода является:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
printf("%d", 4 < 5 ? 4 : 5);
\end{minted}

Важно знать, что препроцессор, выполняя подстановки макросов, ничего не знает про приоритет арифметических операций и синтаксическую структуру программы. Рассмотрим следующую программу:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define MIN(x, y) x < y ? x : y

int main()
{
    printf("%d", 10 + MIN(4, 5));
}
\end{minted}
Данная программа выводит {\bf 5}, тогда как скорее всего программист ожидал вывода {\bf 14}. Дело в том, что после раскрытия макроса возникает выражение {\bf 10 + 4 < 5 ? 4 : 5}. Поскольку бинарный {\bf +} имеет приоритет выше, чем у тернарного оператора, данное выражение разбирается транслятором как {\bf (10 + 4) < 5 ? 4 : 5}, а не {\bf 10 + (4 < 5 ? 4 : 5)}, как мог ожидать программист, использующий макрос. Чтобы избегать подобных проблем, у function-like макросов, которые раскрываются в выражение, replacement следует брать в скобки. По той же причине имена параметров макроса в replacement, следует брать в скобки. Корректный макрос {\bf MIN} мог бы выглядеть следующим образом:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define MIN(x, y) ((x) < (y) ? (x) : (y))
\end{minted}

Директива {\bf define} позволяет определять макросы повторно, при этом, в каждой точке программы силу имеет последний {\bf define} данного макроса:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
X
#define X foo
X
#define X bar
X
\end{minted}
раскрывается в:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
X
foo
bar
\end{minted}

Replacement макроса не препроцессируется при определении макроса, но результат раскрытия макроса препроцессируется повторно:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define Y foo
#define X Y
#define Y bar
X                   // раскрывается в bar
\end{minted}

Что произойдет если replacement макроса {\bf M} будет содержать использование макроса {\bf M}? В этом случае возникает рекурсия. По спецификации препроцессор никогда не должен раскрывать макрос {\bf M} изнутри самого себя, а оставлять вложенный идентификатор как есть:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define M { M }
M                   // раскрывается в { M } один раз, второй раз M не раскрывается
\end{minted}

Ещё пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define A a{ B }
#define B b{ C }
#define C c{ A }
A
B
C
\end{minted}
Результат препроцессирования:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
a{ b{ c{ A } } }
b{ c{ a{ B } } }
c{ a{ b{ C } } }
\end{minted}

Директива {\bf \#undef} позволяет разопределить макрос, определенный ранее с помощью директивы {\bf \#define}. Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
X
#define X foo
X
#undef X
X
\end{minted}
Результат препроцессирования:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
X
foo
X
\end{minted}

Директивы {\bf \#ifdef}, {\bf \#ifndef}, {\bf \#if}, {\bf \#else}, {\bf \#elif}, {\bf \#endif} позволяют отпрепроцессировать часть файла, лишь при определенном условии. Директивы {\bf \#ifdef}, {\bf \#ifndef} проверяют определен ли указанный макрос. Например:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#ifdef __x64_64__
typedef unsigned long uint64_t;
#else
typedef unsigned long long uint64_t;
#endif
\end{minted}

Директива \#if позволяет проверить произвольное арифметическое выражение.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define TWO 2
#if TWO + TWO == 4
// ...
#endif
\end{minted}
Директива {\bf \#if} препроцессирует свой аргумент, а затем парсит то, что получилось как арифметическое выражение. Если после препроцессирования в аргументе {\bf \#if} остаются идентификаторы, то они заменяются на 0, кроме идентификатора {\bf true}, который заменяется на 1.

Директива {\bf \#error} обрывает препроцессирование с ошибкой. Ей можно указать сообщение которое будет показано в ошибке. Например:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#if __BYTE_ORDER == __BIG_ENDIAN
// ...
#elif __BYTE_ORDER == __LITTLE_ENDIAN
// ...
#else
#error unknown endianness
#endif
\end{minted}

\subsection{Лучшие практики}
Основной сложностью при использовании макросов препроцессора является то, что препроцессор оперирует на уровне токенов, не зная ничего про контекст где макрос раскрывается. Предположим, что определен макрос {\bf errno}, а где-то ниже программист пытается определить локальную переменную {\bf errno}.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
#define errno (*errno_location())

int process()
{
    int errno = 0;
}
\end{minted}
Результатом препроцессирования этого фрагмента будет:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int process()
{
    int (*errno_location()) = 0;
}
\end{minted}
